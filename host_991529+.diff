diff -Nru host/Makefile host+/Makefile
--- host/Makefile	Wed Mar 15 22:51:39 2000
+++ host+/Makefile	Wed Jun 14 01:01:09 2000
@@ -60,6 +60,8 @@
 # This is the default in either case if you compile stand-alone.
 CONFIGDEFS = -DHOST_RES_SEND
 
+CONFIGDEFS = -DHOST_RES_SEND -DIPV6
+
 # ----------------------------------------------------------------------
 # Include file directories.
 # This program must be compiled with the same include files that
diff -Nru host/README.ip6.int host+/README.ip6.int
--- host/README.ip6.int	Thu Jan  1 01:00:00 1970
+++ host+/README.ip6.int	Wed Jun 14 01:05:05 2000
@@ -0,0 +1,17 @@
+Use -DIPV6 in the Makefile to turn IPv6 addresses recognition. This
+version of host recognizes IPv6 addresses in the following formats:
+
+3ffe:8010::		normal format of a host (mask 128) address
+3ffe:8010::1		normal format of a host (mask 128) address
+3ffe:8010::/28		with mask
+3ffe:8010:2::/28	with mask; :2: will be masked
+3ffe:8010:2		relaxed format; default mask will be 48 in this case
+3ffe:8010/28		default mask 32 but shorten explicitely to 28
+
+All of the above addresses will be transformed into ip6.int domain form,
+e.g. 3ffe:8010/28 -> 1.0.8.E.F.F.3.ip6.int.  ::/0 can be used to ask
+about just ip6.int.
+
+There no IPv6 communication support yet.
+
+rzm@icm.edu.pl
diff -Nru host/defs.h host+/defs.h
--- host/defs.h	Wed Mar 29 20:19:00 2000
+++ host+/defs.h	Tue Jun 13 18:39:39 2000
@@ -87,6 +87,7 @@
 int parse_type		PROTO((char *));
 int parse_class		PROTO((char *));
 char *in_addr_arpa	PROTO((char *));
+char *ip6_int		PROTO((char *));
 char *nsap_int		PROTO((char *));
 void print_host		PROTO((char *, struct hostent *));
 void show_res		PROTO((void));
diff -Nru host/info.c host+/info.c
--- host/info.c	Mon Mar 27 12:59:11 2000
+++ host+/info.c	Tue Jun 13 21:06:15 2000
@@ -63,6 +63,7 @@
 	int nodata = 0;			/* NO_DATA status during DNSRCH */
 	int nquery = 0;			/* number of extra search queries */
 
+	if (name==NULL) return FALSE;
 /*
  * Single dot means root zone.
  */
diff -Nru host/main.c host+/main.c
--- host/main.c	Wed Mar 29 22:38:09 2000
+++ host+/main.c	Wed Jun 14 00:55:58 2000
@@ -1273,6 +1273,7 @@
 input char *name;			/* command line argument */
 {
 	bool result;			/* result status of action taken */
+	bool rev6 = FALSE;
 
 	/* check for nonsense input name */
 	if (strlength(name) > MAXDNAME)
@@ -1297,6 +1298,13 @@
 	else
 		queryaddr = inet_addr(queryname);
 
+#ifdef IPV6
+	if (index(queryname,':')) {
+		rev6 = TRUE;
+		queryname = ip6_int(queryname);
+	}
+#endif
+
 /*
  * Generate reverse in-addr.arpa query if so requested.
  * The input name must be a dotted quad, and be convertible.
@@ -1304,7 +1312,11 @@
 	if (reverse)
 	{
 		if (queryaddr == NOT_DOTTED_QUAD)
-			name = NULL;
+			if (rev6) {
+				name = ip6_int(queryname);
+			} else {
+				name = NULL;
+			}
 		else
 			name = in_addr_arpa(queryname);
 
@@ -1323,18 +1335,18 @@
  * Heuristic to check whether we are processing a reverse mapping domain.
  * Normalize to not have trailing dot, unless it is the root zone.
  */
-	if ((queryaddr == NOT_DOTTED_QUAD) && !reverse)
+	if ((queryaddr == NOT_DOTTED_QUAD) && !rev6 && !reverse)
 	{
 		char namebuf[MAXDNAME+1];
 		register int n;
 
-		name = strcpy(namebuf, queryname);
+		name = strncpy(namebuf, queryname, sizeof(namebuf));
 
 		n = strlength(name);
 		if (n > 1 && name[n-1] == '.')
 			name[n-1] = '\0';
 
-		reverse = indomain(name, ARPA_ROOT, FALSE);
+		reverse = indomain(name, ARPA_ROOT, FALSE) || indomain(name, IPNG_ROOT, FALSE);
 	}
 
 /*
@@ -1370,7 +1382,7 @@
 	/* set querytype for regular mode if unspecified */
 	if ((querytype == T_NONE) && !listmode)
 	{
-		if ((queryaddr != NOT_DOTTED_QUAD) || reverse)
+		if ((queryaddr != NOT_DOTTED_QUAD) || rev6 || reverse)
 			querytype = T_PTR;
 		else
 			querytype = T_A;
diff -Nru host/util.c host+/util.c
--- host/util.c	Mon Mar 27 13:34:15 2000
+++ host+/util.c	Wed Jun 14 01:00:08 2000
@@ -209,6 +209,78 @@
 }
 
 /*
+** IP6_INT -- Convert IPv6 string to reverse ip6.int
+** ------------------------------------------------------------------
+**
+**	Returns:
+**		Pointer to appropriate reverse ip6.int name with
+**		trailing dot to force absolute domain name. NULL
+**		in case of invalid IPv6 input string.
+*/
+
+char *
+ip6_int(ipv6)
+input char *ipv6;			/* input string with IPv6 */
+{
+	static char dombuf[ 128/4*3 + sizeof(IPNG_ROOT) + 2];
+#ifdef IPV6
+	char ipv6addr [8*4 + 7 + 1 + 3 + 2], *mask, *p, buf2[5];
+	struct in6_addr ip6buf;
+	int nmask = -1, err, i, colons = 0;
+
+	strncpy(ipv6addr, ipv6, sizeof(ipv6addr));
+
+	mask = index(ipv6addr, '/');
+	if (mask) {
+		*mask = '\0';
+		mask++;
+		nmask = atoi(mask);
+	}
+
+	p = ipv6addr; while(*p) if (*p++==':') colons++;
+/* printf("addr: %s, colons: %d, last: %c\n", ipv6addr, colons, p[-1]); */
+
+	/* relaxing address format: remove last : */
+	if ( (p-ipv6addr>=2) && (p[-1]==':') && (p[-2]!=':') ) p[-1] = '\0';
+	
+	/* mask not set, derived from non-standard formatted address */
+	if ( (colons<7) && (p[-1]!=':') && (strstr(ipv6addr,"::")==0) ) {
+		strcat(ipv6addr, "::");
+		if (nmask==-1) nmask = (colons+1)*16;
+	}
+
+	if (nmask==-1) nmask = 128;
+
+	err = inet_pton(AF_INET6, ipv6addr, &ip6buf);
+	if (err == -1) {
+		errmsg("Address (%s) format error: %s", ipv6, strerror(errno));
+		return ipv6;
+	}
+	if (err == 0) {
+		errmsg("Address `%s' not valid");
+		return ipv6;
+	}
+
+/* for (i=0; i<16; i++) printf("%02X ", ip6buf.s6_addr[i]); printf("/%d\n", nmask); */
+
+	nmask -= nmask%4;
+	dombuf[0] = '\0';
+	while (nmask>0) {
+		if (nmask%8==0) {
+			sprintf(buf2, "%X.", ip6buf.s6_addr[(nmask-1)/8] % 16);
+		} else {
+			sprintf(buf2, "%X.", ip6buf.s6_addr[(nmask-1)/8] / 16);
+		}
+		strcat(dombuf, buf2);
+		nmask -= 4;	/* 8 bits at a time */
+	}
+	strcat(dombuf, IPNG_ROOT);
+	strcat(dombuf, ".");
+#endif
+	return dombuf;
+}
+
+/*
 ** NSAP_INT -- Convert dotted nsap address string to reverse nsap.int
 ** ------------------------------------------------------------------
 **
